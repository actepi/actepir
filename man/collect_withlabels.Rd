% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collect_withlabels.R
\name{collect_withlabels}
\alias{collect_withlabels}
\title{Collect in dbplyr pipe with labels}
\usage{
collect_withlabels(
  dataset,
  lbl_db = NULL,
  lbl_schema = NULL,
  lbl_table = NULL,
  driver = NULL,
  max_attempts = NULL
)
}
\arguments{
\item{dataset}{The name of the dataset that labels are associated with. Argument should be supplied as character or object.}

\item{lbl_db}{The name of the database to be connected to. Argument should be supplied as character.}

\item{lbl_schema}{The name of the schema to be connected to. Argument should be supplied as character.}

\item{lbl_table}{The name of the table where the labels exist. Argument should be supplied as character.}
}
\description{
This function is a wraparound function which combines the \code{episerver_getlabels} and \code{dplyr::collect} functions and feeds them to the \code{applydatalabels} function.  It will allow the user to collect the result of a lazy query with associated labels when the query is placed against an EpiServer location.  The function will always search EpiServer and cannot be used for other servers of file locations.
}
\details{
Almost all non-administrative users will not need to use the lbl_* arguments.  In most cases, when accessing the "Analysis" database, you will not need to supply the "dataset" argument.
}
\examples{
# One-step process: apply labels as part of collect() 
# statement when a dbplyr lazy object is passed to it
dat = episerver_connect("APC") \%>\% 
  collect_withlabels()

# One-step process: apply labels as part of collect() 
# statement but source labels from another location
dat = episerver_connect("APC") \%>\% 
  collect_withlabels(
    dataset = "APC", 
    lbl_table = "DataLabelsNew", 
    lbl_schema = "dbo", 
    lbl_db = "HospitalAPC"
    )
  
}
\keyword{episerver}
